## 设计模式

### 程序设计六大原则

- 单一原则
- 里氏替换原则
- 依赖倒置原则
- 接口隔离原则
- 迪米特法则
- 开闭原则

### 创建型

#### 单例模式

- demo1

```javascript
var zhangsan = (function() {
  var zhangsan = function(msg) {
    this.menling = msg;
  }
  var men;
  var info = {
    sendMessage: function(message) {
      if(!men) {
        men = new zhangsan(message)
      }
      return men
    }
  }
  return info;
})()

var lisi = {
  callZhangsan(msg) {
    var _zhangsan = zhangsan.sendMessage(msg)
    alert(_zhangsan.menling)
    _zhangsan = null;
  }
}

var wangwu = {
  callZhangsan(msg) {
    var _zhangsan = zhangsan.sendMessage(msg)
    alert(_zhangsan.menling)
  }
}

lisi.callZhangsan('dingdong');
wangwu.callZhangsan('dingding');
```

- demo2

```javascript
<button id="open">打开</button>
<button id="delete">关闭</button>
let Model = function (id, html) {
  this.id = id;
  this.html = html;
  this.open = false;
};
Model.prototype.create = function () {
  if (!this.open) {
    let model = document.createElement("div");
    model.innerHTML = this.html;
    model.id = this.id;
    document.body.appendChild(model);
    this.open = true;
    model.classList.add("show");
  }
};
Model.prototype.delete = function () {
  if (this.open) {
    let model = document.getElementById(this.id);
    document.body.removeChild(model);
    this.open = false;
  }
};
let createInstance = (function () {
  let instance;
  return function () {
    return instance || (instance = new Model("model", "我是布莱克"));
  };
})();
let operate = {
  setModel: null,
  open() {
    this.setModel = createInstance();
    this.setModel.create();
  },
  delete() {
    this.setModel ? this.setModel.delete() : "";
  },
};
document.getElementById("open").onclick = function () {
  operate.open();
};
document.getElementById("delete").onclick = function () {
  operate.delete();
};

```

#### 工厂模式

将new操作单独封装

遇到new时，就要考虑是否使用工厂模式

- 简单工厂

  ```javascript
  // 简单工厂 适合需求情况比较少
  let factory = function (name, age, sex, national) {
    this.name = name;
    this.age = age;
    this.sex = sex;
    switch (national) {
      case "Chinese":
        this.speak = function () {
          console.log(
            `我叫 ${this.name}, 我今年 ${this.age}, 我的性别是 ${this.sex}，我说中国话`
          );
        };
        break;
      case "England":
        this.speak = function () {
          console.log(
            `i am ${this.name}, my age is ${this.age}, my sex is ${this.sex}, i speak english`
          );
        };
        break;
    }
  };
  
  let person1 = new factory("jack", 15, "boy", "England");
  person1.speak();
  
  ```

- 抽象工厂模式

  ```javascript
  // 抽象工厂模式
  function MyCar(color, price) {
    this.color = color;
    this.price = price;
  }
  MyCar.prototype.run = function () {
    throw new Error("我是接口， 具体怎么做， 你们子类自己去玩");
  };
  let BMW = function (color, price) {
    MyCar.call(this, color, price);
  };
  BMW.prototype.run = function () {
    console.log(
      `i am bmw, my color is ${this.color}, my price is ${this.price}, BMW is running`
    );
  };
  let bmw = new BMW("red", 998);
  bmw.run();
  
  
  let BenChi = function (color, price) {
    MyCar.call(this, color, price);
  };
  BenChi.prototype.run = function () {
    console.log(
      `i am bmw, my color is ${this.color}, my price is ${this.price}, BenChi is running`
    );
  };
  let bc = new BenChi("yellow", 889);
  bc.run();
  
  ```

#### 原型模式

- clone自己，生成一个新对象
- java默认有clone接口，不用自己实现
- Object.create用到了原型模式的思想

对比js中的原型prototype

- prototype可以理解为ES6 class的一种底层原理
- 而class是实现面向对象的基础，并不是服务于某个模式
- Object.create会长久存在

```javascript
// 一个原型对象
      let prototype = {
        getName() {
          return this.first + " " + this.last;
        },
        say() {
          console.log("hello");
        },
      };

      // 基于原型对象创建x
      let x = Object.create(prototype);
      x.first = "A";
      x.last = "B";
      console.log(x.getName());
      x.say();
      // 基于原型对象创建y
      let y = Object.create(prototype);
      y.first = "C";
      y.last = "D";
      console.log(y.getName());
      y.say();
```



### 结构型

#### 代理模式

- demo1

  ```javascript
  let Shoes = function (name) {
    this.name = name;
  };
  Shoes.prototype.getName = function () {
    return this.name;
  };
  let assistant = {
    buyShoes: function(shoes) {
      star.buyShoes(shoes.getName())
    }
  }
  let star = {
    buyShoes: function (name) {
      console.log(`buy a${name}`)
    },
  };
  assistant.buyShoes(new Shoes("adidas"));
  ```

- demo2

  ```javascript
  let ad = function (price) {
    this.price = price;
  };
  ad.prototype.getPrice = function () {
    return this.price;
  };
  let assistant = {
    init(ad) {
      let money = ad.getPrice();
      if (money > 300) {
        this.receiveAd(money);
      } else {
        this.rejectAd(money);
      }
    },
    receiveAd(price) {
      star.receiveAd(price);
    },
    rejectAd(price) {
      star.rejectAd(price);
    },
  };
  let star = {
    receiveAd(price) {
      console.log(`ok: i agree this ad which price is ${price}`);
    },
    rejectAd(price) {
      console.log(`sorry: ${price} is too low`);
    },
  };
  assistant.init(new ad(500));
  assistant.init(new ad(100));
  ```

#### 适配器模式

为了解决软件实体间的接口不兼容，使用适配器以后原本不兼容的两个软件的接口可以在一起。

原则：不要改变原始软件的程序。

使用场景

- 封装旧接口
- vue computed



- demo1

  ```javascript
  let googleMap = {
    show() {
      console.log(`start render google map`);
    },
  };
  
  let baiduMap = {
    display() {
      console.log(`start render baidu map`);
    },
  };
  let baiduAdapter = {
    show() {
      return baiduMap.display()
    }
  }
  let renderMap = function (map) {
    if (map instanceof Object) {
      map.show();
    }
  };
  renderMap(googleMap);
  renderMap(baiduAdapter);
  
  ```

- demo2

  ```javascript
  let getBeijingCity = (function () {
    let beijingCity = [
      { name: "chaoyang", id: 11 },
      { name: "haiding", id: 12 },
      { name: "daqing", id: 13 },
    ];
    return beijingCity;
  })();
  
  let render = function (fn) {
    console.log(`start beijing map`);
    document.write(JSON.stringify(fn));
  };
  
  let addressAdapter = function (oldAddressfn) {
    let address = {};
    oldAddressfn.forEach((city) => {
      address[city.name] = city.id;
    });
    return address;
  };
  
  // render(getBeijingCity);
  render(addressAdapter(getBeijingCity));
  ```

#### 装饰器模式

```javascript
class Circle {
        draw() {
          console.log("画一个圆");
        }
      }

      class Decorator {
        constructor(circle) {
          this.circle = circle;
        }
        draw() {
          this.circle.draw();
          this.setRedBorder(this.circle);
        }
        setRedBorder(circle) {
          console.log(`设置红色边框`);
        }
      }

      // test

      let circle = new Circle();
      circle.draw();
      console.log("-----------------------------");
      let dec = new Decorator(circle);
      dec.draw();
```

es7装饰器

```javascript
@testDec(false)
class Demo {}
function testDec(isDec) {
  return function (target) {
    target.isDec = isDec;
  };
}
alert(Demo.isDec);
```



```javascript
function mixins(...list) {
  console.log(...list);
  return function (target) {
    console.log(target);
    Object.assign(target.prototype, ...list);
  };
}
const Foo = {
  foo() {
    alert("foo");
  },
};
const Bar = {
  bar() {
    alert("bar");
  },
};
@mixins(Foo, Bar)
class MyClass {
  constructor() {
    this.test = "test";
  }
}
let demo = new MyClass();
demo.foo();
demo.bar();
```



```javascript
function readonly(target, name, descriptor) {
  descriptor.writable = false;
  return descriptor
}

class Person {
  constructor() {
    this.first = 'A'
    this.last = 'B'
  }
  @readonly
  name() {
    return `${this.first} ${this.last}`
  }
}

let p = new Person();
console.log(p.name())
*/
// 报错
// p.name = function() {
//   alert(100)
// }
```



```javascript
function log(target, name, descriptor) {
  console.log(descriptor);
  let oldValue = descriptor.value;
  descriptor.value = function () {
    console.log(`calling ${name} with`, arguments);
    return oldValue.apply(this, arguments);
  };
  return descriptor;
}

class Math {
  @log
  add(a, b) {
    return a + b;
  }
}

let math = new Math();
const result = math.add(2, 4);
console.log(result);
```

#### 代理模式vs适配器模式

- 适配器模式：提供一个不同的接口（如不同版本的插头）
- 代理模式： 提供一模一样的接口

#### 代理模式vs装饰器模式

- 装饰器模式：扩展功能，原有功能不变且可直接使用
- 代理模式：显示原有功能，但是经过限制或者阉割之后的

#### 外观模式

- 为子系统中的一组接口提供了一个高层接口
- 使用者使用这个高层接口
- 不符合单一职责原则和开放封闭原则，因此谨慎使用，不可滥用

#### 桥接模式

#### 组合模式

#### 享元模式

### 行为性 - 1

#### 策略模式

#### 模板方法模式

#### 观察者模式

主题和观察者分离，不是主动触发而是被动监听，两者解耦

符合开放封闭原则

- 发布&订阅

- 一对多

  使用场景

  - onClick事件
  - promise
  - JQ Cb
  - vue eventBus
  - node
  - nodejs：处理http请求 req.on()；多进程通信
  - vue和react组件生命周期触发
  - vue watch

```javascript
 // 主题，保存状态，状态变化之后会触发所有观察者对象
      class Subject {
        constructor() {
          this.state = 0;
          this.observers = [];
        }
        getState() {
          return this.state;
        }
        setState(state) {
          this.state = state;
          this.notifyAllObservers();
        }
        notifyAllObservers() {
          this.observers.forEach((observer) => {
            observer.update();
          });
        }
        attach(observer) {
          this.observers.push(observer);
        }
      }

      // 观察者
      class Observer {
        constructor(name, subject) {
          this.name = name;
          this.subject = subject;
          this.subject.attach(this);
        }
        update() {
          console.log(
            `${this.name} update, state: ${this.subject.getState()}`
          );
        }
      }

      // test

      let sub = new Subject();
      let o1 = new Observer("o1", sub);
      let o2 = new Observer("o2", sub);
      let o3 = new Observer("o3", sub);
      sub.setState(1);
      sub.setState(2);
      sub.setState(3);
```



node

```javascript
const EventEmitter = require('events').EventEmitter;

/*
const emitter1 = new EventEmitter()
// 监听some事件
emitter1.on('some', info => {
  console.log('fn1', info)
})
emitter1.on('some', info => {
  console.log('fn2', info)
})
// 触发some
emitter1.emit('some', 'xxxxx')
*/

// 继承
// class Dog extends EventEmitter {
//   constructor(name) {
//     super()
//     this.name = name
//   }
// }

// let simon = new Dog('simon')
// simon.on('bark', function() {
//   console.log(this.name, 'barked')
// })
// setInterval(() => {
//   simon.emit('bark')
// }, 1000)

// stream 用到自定义事件
const fs = require('fs');
const readLine = require('readline');
const readStream = fs.createReadStream('./demoFile.txt')
let length = 0;
let lines = 0;
let rl = readLine.createInterface({
  input: fs.createReadStream('./demoFile.txt')
})
rl.on('line', function(line){
  lines++;
})
rl.on('close', function() {
  console.log('lines', lines)
})
readStream.on('data', function (chunk) {
  let len = chunk.toString().length;
  console.log('len', len);
  length += len;
})
readStream.on('end', function () {
  console.log('length', length)
})
```

#### 迭代器模式

- 顺序访问一个集合
- 使用者无需知道集合的内部结构（封装）

使用场景

- JQ each
- es6 iterator
  - 有序集合的数据类型Array Map Set String TypedArray arguments NodeList
  - 以上数据类型，都有[Symbol.iterator]属性
  - 属性值是函数，执行函数返回一个迭代器
  - 这个迭代器就有next方法可以顺序迭代子元素
  - 可运行Array.prototype[Symbol.iterator]来测试
  - iterator的价值不限于上述几个类型的遍历
  - 还有Generator函数的使用
  - 即只要返回的数据符合Iterator接口的要求
  - 即可使用iterator语法，这就是迭代器模式

```javascript
<div id="div1">
      <a href="#">a1</a>
      <a href="#">a2</a>
      <a href="#">a3</a>
      <a href="#">a4</a>
      <a href="#">a5</a>
    </div>
    <script
      src="https://code.jquery.com/jquery-3.5.1.js"
      integrity="sha256-QWo7LDvxbWT2tbbQ97B53yJnYU3WhH/C8ycbRAkjPDc="
      crossorigin="anonymous"
    ></script>
    <script>
      let arr = [1, 2, 3];
      let nodeList = document.getElementsByTagName("a");
      let $a = $("a");
      // 遍历数组
      // arr.forEach(function (item) {
      //   console.log(item);
      // });
      // // 遍历nodeList
      // for (let i = 0, len = nodeList.length; i < len; i++) {
      //   console.log(nodeList[i]);
      // }
      // // 遍历 $a
      // $a.each(function (key, elem) {
      //   console.log(key, elem);
      // });

      function each(data) {
        // 生成迭代器
        let $data = $(data);
        $data.each(function (key, val) {
          console.log(key, val);
        });
      }
      each(arr);
      each(nodeList);
      each($a);
```



```javascript
 class Iterator {
        constructor(container) {
          this.list = container.list;
          this.index = 0;
        }
        next() {
          if (this.hasNext()) {
            return this.list[this.index++];
          }
          return null;
        }
        hasNext() {
          if (this.index >= this.list.length) {
            return false;
          }
          return true;
        }
      }
      class Container {
        constructor(list) {
          this.list = list;
        }
        // 生成迭代器
        getIterator() {
          return new Iterator(this);
        }
      }

      // test

      let arr = [1, 2, 3, 4, 5, 6];
      let container = new Container(arr);
      let iterator = container.getIterator();
      while (iterator.hasNext()) {
        console.log(iterator.next());
      }
      let nodeList = document.getElementsByTagName("a");
      let nodeListContainer = new Container(nodeList);
      let nodeListIterator = nodeListContainer.getIterator();
      while (nodeListIterator.hasNext()) {
        console.log(nodeListIterator.next());
      }
```



```javascript
<p>111</p>
    <p>222</p>
    <p>333</p>
    <script>
      function each(data) {
        // 生成迭代器
        // let iterator = data[Symbol.iterator]();
        // let item = {done: false}
        // while(!item.done) {
        //   item = iterator.next()
        //   if(!item.done) {
        //     console.log(item.value)
        //   }
        // }

		// 带有遍历器特性的对象: data[Symbol.iterator] 有值
        for(let item of data) {
          console.log(item)
        }
        console.log('-----------------------');
        
      }

      let arr = [1, 2, 3, 4];
      let nodelist = document.getElementsByTagName("p");
      let m = new Map();
      m.set("a", 100);
      m.set("b", 100);
      each(arr);
      each(nodelist);
      each(m);
```



#### 职责模式

#### 命令模式

### 行为性 - 2

#### 备忘录模式

#### 状态模式

- 一个对象有状态变化
- 每次状态变化都会触发一个逻辑
- 不能总用if...else来控制

```javascript
// 状态 红黄绿灯
      class State {
        constructor(color) {
          this.color = color;
        }
        handle(context) {
          console.log(`turn to ${this.color} light`);
          context.setState(this);
        }
      }
      // 主体
      class Context {
        constructor() {
          this.state = null;
        }
        getState() {
          return this.state;
        }
        setState(state) {
          this.state = state;
        }
      }

      // test

      let context = new Context();
      let green = new State("green");
      let yellow = new State("yellow");
      let red = new State("red");

      // 绿灯
      green.handle(context)
      console.log(context.getState())
      
      yellow.handle(context)
      console.log(context.getState())
      
      red.handle(context)
      console.log(context.getState())
```

​	有限状态机

- 有限个状态、以及在这些状态之间的变化
- 如交通信号灯
- 使用开源lib: javascript-state-machine

```javascript
<button id="btn1"></button>



import StateMachine from "javascript-state-machine";
// 初始化状态机模型
let fsm = new StateMachine({
  init: "收藏",
  transitions: [
    {
      name: "doStore",
      from: "收藏",
      to: "取消收藏",
    },
    {
      name: "deleteStore",
      from: "取消收藏",
      to: "收藏",
    },
  ],
  methods: {
    // 监听执行收藏
    onDoStore() {
      alert("收藏成功");
      updateText();
    },
    // 监听取消收藏
    onDeleteStore() {
      alert("取消收藏");
      updateText();
    },
  },
});
let btn = document.getElementById("btn1");
// 更新收藏文案
function updateText() {
  btn.innerHTML = fsm.state;
}


// 按钮点击事件
btn.onclick = function () {
  if (fsm.is("收藏")) {
    fsm.doStore();
  } else {
    fsm.deleteStore();
  }
};

// 初始化文案
updateText();
```



promise就是状态有限机

手写一个简单的promise

```javascript
// 手写简易promise
import StateMachine from "javascript-state-machine";

// 状态机模型
let fsm = new StateMachine({
  init: 'pending',
  transitions: [
    {
      name: 'resolve',
      from: 'pending',
      to: 'fullfilled'
    },
    {
      name: 'reject',
      from: 'pending',
      to: 'rejected'
    }
  ],
  methods: {
    // 监听resolve
    onResolve(state, data) {
      // state - 当前状态机实例 data - fsm.resolve(xxx)传递的参数
      data.successList.forEach(fn => fn())
    },
    onReject(state, data) {
      // state - 当前状态机实例 data - fsm.reject(xxx)传递的参数
      data.failList.forEach(fn => fn())
    }
  }
})

// 定义promise 
class MyPromise {
  constructor(fn) {
    this.successList = [];
    this.failList = [];
    fn(() => {
      // resolve函数
      fsm.resolve(this)
    }, () => {
      // reject函数
      fsm.reject(this)
    })
  }
  then(successFn, failFn) {
    this.successList.push(successFn)
    this.failList.push(failFn)
  }
}

// test
function loadImg(src) {
  const promise = new MyPromise(function(resolve, reject) {
    let img = document.createElement('img')
    img.onload = function () {
      resolve(img)
    }
    img.onerror = function () {
      reject()
    }
    img.src = src;
    document.body.appendChild(img)
  })
  return promise
}

let src = '../img/home_ill.png';
let result = loadImg(src);

result.then(function () {
  console.log('ok1')
}, function () {
  console.log('failed1')
})


result.then(function () {
  console.log('ok2')
}, function () {
  console.log('failed2')
})
```



#### 访问者模式

#### 中介者模式

#### 解释器模式