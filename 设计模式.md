## 设计模式

### 程序设计六大原则

- 单一原则
- 里氏替换原则
- 依赖倒置原则
- 接口隔离原则
- 迪米特法则
- 开闭原则

### 创建型

#### 单例模式

- demo1

```javascript
var zhangsan = (function() {
  var zhangsan = function(msg) {
    this.menling = msg;
  }
  var men;
  var info = {
    sendMessage: function(message) {
      if(!men) {
        men = new zhangsan(message)
      }
      return men
    }
  }
  return info;
})()

var lisi = {
  callZhangsan(msg) {
    var _zhangsan = zhangsan.sendMessage(msg)
    alert(_zhangsan.menling)
    _zhangsan = null;
  }
}

var wangwu = {
  callZhangsan(msg) {
    var _zhangsan = zhangsan.sendMessage(msg)
    alert(_zhangsan.menling)
  }
}

lisi.callZhangsan('dingdong');
wangwu.callZhangsan('dingding');
```

- demo2

```javascript
<button id="open">打开</button>
<button id="delete">关闭</button>
let Model = function (id, html) {
  this.id = id;
  this.html = html;
  this.open = false;
};
Model.prototype.create = function () {
  if (!this.open) {
    let model = document.createElement("div");
    model.innerHTML = this.html;
    model.id = this.id;
    document.body.appendChild(model);
    this.open = true;
    model.classList.add("show");
  }
};
Model.prototype.delete = function () {
  if (this.open) {
    let model = document.getElementById(this.id);
    document.body.removeChild(model);
    this.open = false;
  }
};
let createInstance = (function () {
  let instance;
  return function () {
    return instance || (instance = new Model("model", "我是布莱克"));
  };
})();
let operate = {
  setModel: null,
  open() {
    this.setModel = createInstance();
    this.setModel.create();
  },
  delete() {
    this.setModel ? this.setModel.delete() : "";
  },
};
document.getElementById("open").onclick = function () {
  operate.open();
};
document.getElementById("delete").onclick = function () {
  operate.delete();
};

```

#### 工厂模式

将new操作单独封装

遇到new时，就要考虑是否使用工厂模式

- 简单工厂

  ```javascript
  // 简单工厂 适合需求情况比较少
  let factory = function (name, age, sex, national) {
    this.name = name;
    this.age = age;
    this.sex = sex;
    switch (national) {
      case "Chinese":
        this.speak = function () {
          console.log(
            `我叫 ${this.name}, 我今年 ${this.age}, 我的性别是 ${this.sex}，我说中国话`
          );
        };
        break;
      case "England":
        this.speak = function () {
          console.log(
            `i am ${this.name}, my age is ${this.age}, my sex is ${this.sex}, i speak english`
          );
        };
        break;
    }
  };
  
  let person1 = new factory("jack", 15, "boy", "England");
  person1.speak();
  
  ```

- 抽象工厂模式

  ```javascript
  // 抽象工厂模式
  function MyCar(color, price) {
    this.color = color;
    this.price = price;
  }
  MyCar.prototype.run = function () {
    throw new Error("我是接口， 具体怎么做， 你们子类自己去玩");
  };
  let BMW = function (color, price) {
    MyCar.call(this, color, price);
  };
  BMW.prototype.run = function () {
    console.log(
      `i am bmw, my color is ${this.color}, my price is ${this.price}, BMW is running`
    );
  };
  let bmw = new BMW("red", 998);
  bmw.run();
  
  
  let BenChi = function (color, price) {
    MyCar.call(this, color, price);
  };
  BenChi.prototype.run = function () {
    console.log(
      `i am bmw, my color is ${this.color}, my price is ${this.price}, BenChi is running`
    );
  };
  let bc = new BenChi("yellow", 889);
  bc.run();
  
  ```

#### 原型模式

### 结构型

#### 代理模式

- demo1

  ```javascript
  let Shoes = function (name) {
    this.name = name;
  };
  Shoes.prototype.getName = function () {
    return this.name;
  };
  let assistant = {
    buyShoes: function(shoes) {
      star.buyShoes(shoes.getName())
    }
  }
  let star = {
    buyShoes: function (name) {
      console.log(`buy a${name}`)
    },
  };
  assistant.buyShoes(new Shoes("adidas"));
  ```

- demo2

  ```javascript
  let ad = function (price) {
    this.price = price;
  };
  ad.prototype.getPrice = function () {
    return this.price;
  };
  let assistant = {
    init(ad) {
      let money = ad.getPrice();
      if (money > 300) {
        this.receiveAd(money);
      } else {
        this.rejectAd(money);
      }
    },
    receiveAd(price) {
      star.receiveAd(price);
    },
    rejectAd(price) {
      star.rejectAd(price);
    },
  };
  let star = {
    receiveAd(price) {
      console.log(`ok: i agree this ad which price is ${price}`);
    },
    rejectAd(price) {
      console.log(`sorry: ${price} is too low`);
    },
  };
  assistant.init(new ad(500));
  assistant.init(new ad(100));
  ```

#### 适配器模式

为了解决软件实体间的接口不兼容，使用适配器以后原本不兼容的两个软件的接口可以在一起。

原则：不要改变原始软件的程序。

使用场景

- 封装旧接口
- vue computed



- demo1

  ```javascript
  let googleMap = {
    show() {
      console.log(`start render google map`);
    },
  };
  
  let baiduMap = {
    display() {
      console.log(`start render baidu map`);
    },
  };
  let baiduAdapter = {
    show() {
      return baiduMap.display()
    }
  }
  let renderMap = function (map) {
    if (map instanceof Object) {
      map.show();
    }
  };
  renderMap(googleMap);
  renderMap(baiduAdapter);
  
  ```

- demo2

  ```javascript
  let getBeijingCity = (function () {
    let beijingCity = [
      { name: "chaoyang", id: 11 },
      { name: "haiding", id: 12 },
      { name: "daqing", id: 13 },
    ];
    return beijingCity;
  })();
  
  let render = function (fn) {
    console.log(`start beijing map`);
    document.write(JSON.stringify(fn));
  };
  
  let addressAdapter = function (oldAddressfn) {
    let address = {};
    oldAddressfn.forEach((city) => {
      address[city.name] = city.id;
    });
    return address;
  };
  
  // render(getBeijingCity);
  render(addressAdapter(getBeijingCity));
  ```

#### 装饰器模式

```javascript
class Circle {
        draw() {
          console.log("画一个圆");
        }
      }

      class Decorator {
        constructor(circle) {
          this.circle = circle;
        }
        draw() {
          this.circle.draw();
          this.setRedBorder(this.circle);
        }
        setRedBorder(circle) {
          console.log(`设置红色边框`);
        }
      }

      // test

      let circle = new Circle();
      circle.draw();
      console.log("-----------------------------");
      let dec = new Decorator(circle);
      dec.draw();
```

es7装饰器

```javascript
@testDec(false)
class Demo {}
function testDec(isDec) {
  return function (target) {
    target.isDec = isDec;
  };
}
alert(Demo.isDec);
```



```javascript
function mixins(...list) {
  console.log(...list);
  return function (target) {
    console.log(target);
    Object.assign(target.prototype, ...list);
  };
}
const Foo = {
  foo() {
    alert("foo");
  },
};
const Bar = {
  bar() {
    alert("bar");
  },
};
@mixins(Foo, Bar)
class MyClass {
  constructor() {
    this.test = "test";
  }
}
let demo = new MyClass();
demo.foo();
demo.bar();
```



```javascript
function readonly(target, name, descriptor) {
  descriptor.writable = false;
  return descriptor
}

class Person {
  constructor() {
    this.first = 'A'
    this.last = 'B'
  }
  @readonly
  name() {
    return `${this.first} ${this.last}`
  }
}

let p = new Person();
console.log(p.name())
*/
// 报错
// p.name = function() {
//   alert(100)
// }
```



```javascript
function log(target, name, descriptor) {
  console.log(descriptor);
  let oldValue = descriptor.value;
  descriptor.value = function () {
    console.log(`calling ${name} with`, arguments);
    return oldValue.apply(this, arguments);
  };
  return descriptor;
}

class Math {
  @log
  add(a, b) {
    return a + b;
  }
}

let math = new Math();
const result = math.add(2, 4);
console.log(result);
```

#### 代理模式vs适配器模式

- 适配器模式：提供一个不同的接口（如不同版本的插头）
- 代理模式： 提供一模一样的接口

#### 代理模式vs装饰器模式

- 装饰器模式：扩展功能，原有功能不变且可直接使用
- 代理模式：显示原有功能，但是经过限制或者阉割之后的

#### 外观模式

- 为子系统中的一组接口提供了一个高层接口
- 使用者使用这个高层接口
- 不符合单一职责原则和开放封闭原则，因此谨慎使用，不可滥用

#### 桥接模式

#### 组合模式

#### 享元模式

### 行为性 - 1

#### 策略模式

#### 模板方法模式

#### 观察者模式

主题和观察者分离，不是主动触发而是被动监听，两者解耦

符合开放封闭原则

- 发布&订阅

- 一对多

  使用场景

  - onClick事件
  - promise
  - JQ Cb
  - vue eventBus
  - node
  - nodejs：处理http请求 req.on()；多进程通信
  - vue和react组件生命周期触发
  - vue watch

```javascript
 // 主题，保存状态，状态变化之后会触发所有观察者对象
      class Subject {
        constructor() {
          this.state = 0;
          this.observers = [];
        }
        getState() {
          return this.state;
        }
        setState(state) {
          this.state = state;
          this.notifyAllObservers();
        }
        notifyAllObservers() {
          this.observers.forEach((observer) => {
            observer.update();
          });
        }
        attach(observer) {
          this.observers.push(observer);
        }
      }

      // 观察者
      class Observer {
        constructor(name, subject) {
          this.name = name;
          this.subject = subject;
          this.subject.attach(this);
        }
        update() {
          console.log(
            `${this.name} update, state: ${this.subject.getState()}`
          );
        }
      }

      // test

      let sub = new Subject();
      let o1 = new Observer("o1", sub);
      let o2 = new Observer("o2", sub);
      let o3 = new Observer("o3", sub);
      sub.setState(1);
      sub.setState(2);
      sub.setState(3);
```



node

```javascript
const EventEmitter = require('events').EventEmitter;

/*
const emitter1 = new EventEmitter()
// 监听some事件
emitter1.on('some', info => {
  console.log('fn1', info)
})
emitter1.on('some', info => {
  console.log('fn2', info)
})
// 触发some
emitter1.emit('some', 'xxxxx')
*/

// 继承
// class Dog extends EventEmitter {
//   constructor(name) {
//     super()
//     this.name = name
//   }
// }

// let simon = new Dog('simon')
// simon.on('bark', function() {
//   console.log(this.name, 'barked')
// })
// setInterval(() => {
//   simon.emit('bark')
// }, 1000)

// stream 用到自定义事件
const fs = require('fs');
const readLine = require('readline');
const readStream = fs.createReadStream('./demoFile.txt')
let length = 0;
let lines = 0;
let rl = readLine.createInterface({
  input: fs.createReadStream('./demoFile.txt')
})
rl.on('line', function(line){
  lines++;
})
rl.on('close', function() {
  console.log('lines', lines)
})
readStream.on('data', function (chunk) {
  let len = chunk.toString().length;
  console.log('len', len);
  length += len;
})
readStream.on('end', function () {
  console.log('length', length)
})
```

#### 迭代器模式

#### 职责模式

#### 命令模式

### 行为性 - 2

#### 备忘录模式

#### 状态模式

#### 访问者模式

#### 中介者模式

#### 解释器模式